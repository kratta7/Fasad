<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Indelning av fasadbrädor</title>
  <meta name="theme-color" content="#0a84ff">
  <style>
    :root {
      --bg: #ffffff;
      --fg: #111;
      --muted: #666;
      --line: #e6e6e6;
      --accent: #0a84ff;
      --ok: #0b7a0b;
      --err: #b00020;
      --radius: 14px;
      --pad: 14px;
      color-scheme: light dark;
    }
    @media (prefers-color-scheme: dark) {
      :root { --bg: #0c0c0d; --fg: #f2f2f2; --muted: #a2a2a2; --line: #2a2a2a; --accent: #0a84ff; }
    }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }
    .wrap { max-width: 960px; margin: 0 auto; padding: 16px; padding-bottom: 120px; }
    header { position: sticky; top: 0; z-index: 10; backdrop-filter: blur(10px);
      background: color-mix(in oklab, var(--bg) 70%, transparent); border-bottom: 1px solid var(--line); }
    header .inner { max-width: 960px; margin: 0 auto; padding: 12px 16px; }
    h1 { font-size: 20px; margin: 0; }
    p.muted { color: var(--muted); margin: 8px 0 0; font-size: 14px; }
    .card { border: 1px solid var(--line); border-radius: var(--radius); padding: var(--pad); margin: 16px 0; }
    .grid { display: grid; gap: 12px; grid-template-columns: repeat(12, 1fr); }
    .col-12 { grid-column: span 12; } .col-6 { grid-column: span 6; } .col-4 { grid-column: span 4; } .col-3 { grid-column: span 3; }
    @media (max-width: 820px) { .col-6, .col-4, .col-3 { grid-column: span 12; } }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input[type="number"] { width: 100%; padding: 14px 12px; border-radius: 12px; border: 1px solid var(--line);
      background: var(--bg); color: var(--fg); font-size: 16px; -webkit-appearance: none; appearance: textfield; }
    input[type="number"]::-webkit-outer-spin-button, input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .row { margin-bottom: 6px; }
    .actions { position: fixed; left: 0; right: 0; bottom: 0; z-index: 20; padding: 10px 16px;
      background: color-mix(in oklab, var(--bg) 92%, transparent); border-top: 1px solid var(--line);
      display: grid; grid-template-columns: 1fr; gap: 8px; }
    .actions .inner { max-width: 960px; margin: 0 auto; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    @media (max-width: 540px){ .actions .inner { grid-template-columns: 1fr; } }
    button { padding: 14px 16px; border-radius: 12px; border: 1px solid var(--line); background: #f6f6f6; color: #000;
      font-weight: 600; font-size: 16px; }
    button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    button:active { transform: translateY(1px); }
    .status { font-size: 14px; color: var(--muted); margin-top: 8px; min-height: 20px; }
    .status .ok { color: var(--ok); font-weight: 600; }
    .status .err { color: var(--err); font-weight: 600; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { padding: 10px; border-bottom: 1px solid var(--line); text-align: right; font-variant-numeric: tabular-nums; }
    th:first-child, td:first-child, th:nth-child(2), td:nth-child(2) { text-align: left; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid var(--line); font-size: 12px; margin-right: 6px; margin-top: 6px; }
    details summary { cursor: pointer; font-weight: 600; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; }
    .toolbar .left, .toolbar .right { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .copy { font-size: 14px; }
    pre { background: color-mix(in oklab, var(--bg) 92%, transparent); padding: 10px; border-radius: 10px; overflow: auto; border: 1px solid var(--line); }
    .hint { color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <div class="inner">
      <h1>Indelning av fasadbrädor</h1>
      <p class="muted">Två brädbredder i oregelbundet mönster med styrning av springor. Mobilanpassat.</p>
    </div>
  </header>

  <div class="wrap">
    <section class="card">
      <div class="grid">
        <div class="col-6"><div class="row">
          <label for="wallWidth">Väggens bredd (mm)</label>
          <input id="wallWidth" type="number" inputmode="numeric" min="1" step="1" value="6000">
        </div></div>
        <div class="col-6"><div class="row">
          <label for="gapMax">Max springa mellan brädor (mm)</label>
          <input id="gapMax" type="number" inputmode="numeric" min="0" step="1" value="12">
        </div></div>

        <div class="col-6"><div class="row">
          <label for="w1">Brädbredd 1 (mm)</label>
          <input id="w1" type="number" inputmode="numeric" min="1" step="1" value="95">
        </div></div>
        <div class="col-6"><div class="row">
          <label for="w2">Brädbredd 2 (mm)</label>
          <input id="w2" type="number" inputmode="numeric" min="1" step="1" value="120">
        </div></div>

        <div class="col-6"><div class="row">
          <label for="gapMin">Min springa mellan brädor (mm) <span class="hint">(0–3 är vanligt)</span></label>
          <input id="gapMin" type="number" inputmode="numeric" min="0" step="1" value="3">
        </div></div>
        <div class="col-6"><div class="row">
          <label for="ratio1">Målfördelning bredd 1 (%)</label>
          <input id="ratio1" type="number" inputmode="numeric" min="0" max="100" step="1" value="50">
        </div></div>

        <div class="col-6"><div class="row">
          <label for="maxRun">Max antal lika i rad</label>
          <input id="maxRun" type="number" inputmode="numeric" min="1" step="1" value="2">
        </div></div>
        <div class="col-6"><div class="row">
          <label for="seed">Slumpfrö <span class="hint">(samma siffra ⇒ samma mönster)</span></label>
          <input id="seed" type="number" inputmode="numeric" step="1" value="42">
        </div></div>
      </div>
      <div class="status" id="status"></div>
    </section>

    <section class="card">
      <div class="toolbar">
        <div class="left" id="summary"></div>
        <div class="right">
          <button id="btnCSV">Exportera CSV</button>
          <button id="btnCopy" class="copy">Kopiera som text</button>
        </div>
      </div>
      <div id="tableWrap"></div>
    </section>

    <section class="card">
      <details>
        <summary>Hur fungerar det?</summary>
        <p class="hint">
          Verktyget bygger en följd av brädor som ryms inom väggens bredd med minsta springa mellan varje bräda. 
          Återstående utrymme fördelas som extra springa mellan brädorna upp till max-värdet. 
          Val av brädbredd sker slumpmässigt men styrs mot din målfördelning och regeln för högsta antal lika i rad.
        </p>
        <p class="hint">
          Tips för iPhone: spara sidan på hemskärmen (Dela → ”Lägg till på hemskärmen”) för helskärmsläge.
        </p>
      </details>
    </section>
  </div>

  <div class="actions">
    <div class="inner">
      <button class="primary" id="btnRun">Generera mönster</button>
      <button id="btnReset">Återställ</button>
    </div>
  </div>

<script>
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;}}

function generatePattern({wallWidth,w1,w2,gapMin,gapMax,ratio1,maxRun,seed}){
  const rng = mulberry32((seed>>>0)||1);
  if (gapMax < gapMin) throw new Error("Max springa kan inte vara mindre än min springa.");
  if (Math.min(w1,w2) <= 0 || wallWidth <= 0) throw new Error("Ange positiva mått.");
  if (ratio1 < 0 || ratio1 > 100) throw new Error("Målfördelning måste vara 0–100%.");
  if (!Number.isFinite(wallWidth) || !Number.isFinite(w1) || !Number.isFinite(w2)) throw new Error("Kontrollera inmatningen.");
  if (maxRun < 1) maxRun = 1;

  const picks = []; let count1=0, count2=0; let usedWidth=0, gaps=0;
  function minStep(wi, gaps){ return wi + (gaps>0 ? gapMin : 0); }

  while (true){
    const remaining = wallWidth - usedWidth;
    const fits1 = remaining >= minStep(w1, gaps);
    const fits2 = remaining >= minStep(w2, gaps);
    if (!fits1 && !fits2) break;

    const last = picks.slice(-maxRun); let forced=null;
    if (last.length===maxRun && last.every(x=>x===last[0])) forced = last[0]===1?2:1;

    let choice=null;
    if (forced){
      if (forced===1 && fits1) choice = 1;
      else if (forced===2 && fits2) choice = 2;
      else if (fits1) choice = 1;
      else if (fits2) choice = 2;
    } else {
      const total=count1+count2; const target=ratio1/100;
      let p1=target;
      if (total>0){ const diff = target - (count1/total); p1 = Math.min(0.9, Math.max(0.1, target + diff*0.8)); }
      const r=rng(); const preferred=(r<p1)?1:2;
      if (preferred===1 && fits1) choice=1;
      else if (preferred===2 && fits2) choice=2;
      else if (preferred===1 && fits2) choice=2;
      else if (preferred===2 && fits1) choice=1;
    }
    if (!choice) break;
    picks.push(choice); if (choice===1) count1++; else count2++;
    usedWidth += (choice===1?w1:w2);
    if (picks.length>1){ usedWidth += gapMin; gaps++; }
  }

  if (picks.length===0) throw new Error("Inga brädor får plats med givna mått. Minska bredd eller springa.");

  const n=picks.length;
  const baseContent=picks.reduce((s,p)=>s+(p===1?w1:w2),0);
  const baseGaps=(n-1)*gapMin;
  let slack=wallWidth-(baseContent+baseGaps);
  if (slack<-1e-6) throw new Error("Överfullt med minsta springa. Justera måtten.");

  const gapsArr=Array(Math.max(0,n-1)).fill(gapMin);
  const caps=gapsArr.map(()=>gapMax-gapMin);
  let guard=0;
  while (slack>1e-6 && guard<100000){
    guard++; let totalCap=caps.reduce((a,b)=>a+Math.max(0,b),0);
    if (totalCap<=1e-6) break;
    let r=Math.random()*totalCap, idx=0;
    for(; idx<caps.length; idx++){ const c=Math.max(0,caps[idx]); if (r<=c) break; r-=c; }
    if (idx>=caps.length) idx=caps.length-1;
    const inc=Math.min(5,caps[idx],slack);
    gapsArr[idx]+=inc; caps[idx]-=inc; slack-=inc;
  }

  let leftMargin=0,rightMargin=0;
  if (slack>1e-6){ leftMargin=Math.floor(slack/2); rightMargin=Math.ceil(slack-leftMargin); slack=0; }

  let pos=leftMargin; const rows=[];
  for (let i=0;i<n;i++){
    const w=(picks[i]===1?w1:w2);
    const start=pos; const end=start+w;
    const gapAfter=(i<gapsArr.length)?gapsArr[i]:rightMargin;
    rows.push({ nr:i+1, typ:picks[i]===1?`Bredd 1 (${w1})`:`Bredd 2 (${w2})`,
      start_mm:Math.round(start), bredd_mm:w, slut_mm:Math.round(end), springa_efter_mm:Math.round(gapAfter) });
    pos=end+gapAfter;
  }
  const usedTotal = rows.length ? rows[rows.length-1].slut_mm + rows[rows.length-1].springa_efter_mm : 0;
  const maxGapUsed = rows.length>1 ? Math.max(...gapsArr,leftMargin,rightMargin) : 0;
  return { rows, counts:{w1:count1,w2:count2}, maxGapUsed, leftMargin, rightMargin, totalUsed: usedTotal };
}

function fmt(n){ return new Intl.NumberFormat('sv-SE').format(n); }
function renderSummary(out, inputs){
  const s=document.getElementById('summary');
  s.innerHTML = `
    <span class="pill">Brädor: ${out.rows.length}</span>
    <span class="pill">Bredd 1: ${out.counts.w1}</span>
    <span class="pill">Bredd 2: ${out.counts.w2}</span>
    <span class="pill">Max springa: ${fmt(out.maxGapUsed)} mm</span>
    <span class="pill">Vänster marginal: ${fmt(out.leftMargin)} mm</span>
    <span class="pill">Höger marginal: ${fmt(out.rightMargin)} mm</span>
    <span class="pill">Täckt: ${fmt(out.totalUsed)} / ${fmt(inputs.wallWidth)} mm</span>`;
}
function renderTable(rows){
  const wrap=document.getElementById('tableWrap');
  if (!rows || !rows.length){ wrap.innerHTML=""; return; }
  const headers=["#","Typ","Start (mm)","Bredd (mm)","Slut (mm)","Springa efter (mm)"];
  const keys=["nr","typ","start_mm","bredd_mm","slut_mm","springa_efter_mm"];
  let html=`<div style="overflow:auto;"><table><thead><tr>`;
  for (const h of headers){ html+=`<th>${h}</th>`; }
  html+=`</tr></thead><tbody>`;
  for (const r of rows){ html+=`<tr>`+keys.map(k=>`<td>${fmt(r[k])}</td>`).join("")+`</tr>`; }
  html+=`</tbody></table></div>`;
  wrap.innerHTML=html;
}
function getInputs(){
  const wallWidth=parseFloat(document.getElementById('wallWidth').value);
  const w1=parseFloat(document.getElementById('w1').value);
  const w2=parseFloat(document.getElementById('w2').value);
  const gapMax=parseFloat(document.getElementById('gapMax').value);
  const gapMin=parseFloat(document.getElementById('gapMin').value);
  const ratio1=parseFloat(document.getElementById('ratio1').value);
  const maxRun=parseInt(document.getElementById('maxRun').value);
  const seed=parseInt(document.getElementById('seed').value);
  return { wallWidth,w1,w2,gapMin,gapMax,ratio1,maxRun,seed };
}
function toCSV(rows){
  const header=["nr","typ","start_mm","bredd_mm","slut_mm","springa_efter_mm"];
  const lines=[header.join(",")];
  rows.forEach(r=>lines.push([r.nr,r.typ,r.start_mm,r.bredd_mm,r.slut_mm,r.springa_efter_mm].join(",")));
  return lines.join("\n");
}
function toText(rows){
  return rows.map(r=>`${r.nr}. ${r.typ} | start ${r.start_mm} mm → slut ${r.slut_mm} mm | springa efter ${r.springa_efter_mm} mm`).join("\n");
}

const btnRun=document.getElementById('btnRun');
const btnReset=document.getElementById('btnReset');
const btnCSV=document.getElementById('btnCSV');
const btnCopy=document.getElementById('btnCopy');
const statusEl=document.getElementById('status');

function saveInputs(){ try { localStorage.setItem('fasad_inputs', JSON.stringify(getInputs())); } catch(e){} }
function loadInputs(){ try { const s=localStorage.getItem('fasad_inputs'); if (!s) return;
  const v=JSON.parse(s); for (const [k,val] of Object.entries(v)){ const el=document.getElementById(k); if (el && typeof val!=='undefined') el.value=val; } } catch(e){} }
loadInputs();

btnRun.addEventListener('click', ()=>{
  statusEl.textContent="Beräknar…";
  try {
    const inputs=getInputs();
    const out=generatePattern(inputs);
    renderSummary(out, inputs);
    renderTable(out.rows);
    statusEl.innerHTML='<span class="ok">Klart ✔</span>';
    window.__rows=out.rows; saveInputs();
  } catch(e){ statusEl.innerHTML='<span class="err">'+e.message+'</span>'; }
});
btnReset.addEventListener('click', ()=>{
  const defaults={wallWidth:6000,w1:95,w2:120,gapMin:3,gapMax:12,ratio1:50,maxRun:2,seed:42};
  for (const [k,v] of Object.entries(defaults)){ const el=document.getElementById(k); if (el) el.value=v; }
  localStorage.removeItem('fasad_inputs');
  document.getElementById('summary').innerHTML="";
  document.getElementById('tableWrap').innerHTML="";
  statusEl.textContent="";
});
btnCSV.addEventListener('click', ()=>{
  const rows=window.__rows; if (!rows || !rows.length){ statusEl.innerHTML='<span class="err">Generera mönster först.</span>'; return; }
  const csv=toCSV(rows); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='fasad-indelning.csv';
  document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
});
btnCopy.addEventListener('click', async ()=>{
  const rows=window.__rows; if (!rows || !rows.length){ statusEl.innerHTML='<span class="err">Generera mönster först.</span>'; return; }
  const text=toText(rows);
  try { await navigator.clipboard.writeText(text); statusEl.innerHTML='<span class="ok">Kopierat till urklipp.</span>'; }
  catch(e){ const wrap=document.getElementById('tableWrap'); const pre=document.createElement('pre'); pre.textContent=text; wrap.prepend(pre);
    statusEl.innerHTML='<span class="ok">Kopiera texten i rutan ovan.</span>'; }
});
setTimeout(()=>btnRun.click(), 50);
</script>
</body>
</html>
