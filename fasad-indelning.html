<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Indelning av fasadbrädor</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 24px; }
    h1 { margin: 0 0 12px 0; font-size: 20px; }
    fieldset { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
    label { display: block; margin: 6px 0 2px; font-size: 12px; color: #333; }
    input, select { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 6px; }
    .row { display: grid; gap: 12px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #ccc; cursor: pointer; background: #f6f6f6; }
    button.primary { background: #1a73e8; color: white; border-color: #1a73e8; }
    table { width: 100%; border-collapse: collapse; margin-top: 16px; }
    th, td { padding: 8px; border-bottom: 1px solid #eee; text-align: right; }
    th { text-align: right; white-space: nowrap; }
    td:first-child, th:first-child { text-align: left; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #eef3ff; border: 1px solid #d8e3ff; font-size: 12px; }
    .muted { color: #666; font-size: 12px; }
    .wrap { max-width: 1100px; margin: 0 auto; }
    .flex { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .hint { font-size: 12px; color: #666; }
    .error { color: #b00020; font-weight: 600; }
    .ok { color: #0b7a0b; font-weight: 600; }
    details { margin-top: 8px; }
    .spacer { height: 6px;}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Indelning av fasadbrädor</h1>
    <p class="muted">Lägg två brädbredder i oregelbundet mönster inom angiven väggbredd. Anger max-springa mellan brädor (mm). Resultat visas från vänster.</p>

    <fieldset>
      <legend>Inmatning</legend>
      <div class="row">
        <div>
          <label>Väggens bredd (mm)</label>
          <input id="wallWidth" type="number" min="1" step="1" value="6000">
        </div>
        <div>
          <label>Brädbredd 1 (mm)</label>
          <input id="w1" type="number" min="1" step="1" value="95">
        </div>
        <div>
          <label>Brädbredd 2 (mm)</label>
          <input id="w2" type="number" min="1" step="1" value="120">
        </div>
        <div>
          <label>Max springa mellan brädor (mm)</label>
          <input id="gapMax" type="number" min="0" step="1" value="12">
        </div>
        <div>
          <label>Min springa mellan brädor (mm) <span class="muted">(oftast 0–3)</span></label>
          <input id="gapMin" type="number" min="0" step="1" value="3">
        </div>
        <div>
          <label>Målfördelning av bredd 1 (%) <span class="muted">(0–100)</span></label>
          <input id="ratio1" type="number" min="0" max="100" step="1" value="50">
        </div>
        <div>
          <label>Max antal lika i rad</label>
          <input id="maxRun" type="number" min="1" step="1" value="2">
        </div>
        <div>
          <label>Slumpfrö <span class="muted">(samma frö ⇒ samma mönster)</span></label>
          <input id="seed" type="number" step="1" value="42">
        </div>
      </div>
      <div class="spacer"></div>
      <div class="flex">
        <button class="primary" id="btnRun">Generera mönster</button>
        <button id="btnCSV">Exportera CSV</button>
        <span id="status" class="muted"></span>
      </div>
    </fieldset>

    <div id="summary"></div>
    <div id="tableWrap"></div>

    <details>
      <summary>Hur fungerar det?</summary>
      <p class="hint">
        Verktyget bygger en följd av brädor som ryms inom väggens bredd med minst springa mellan varje bräda. 
        Därefter fördelas återstående utrymme som extra springa mellan brädorna, utan att överskrida angivet max. 
        Val av brädbredd görs slumpmässigt men styrs mot angiven målfördelning och regeln för högsta antal lika i rad.
      </p>
    </details>
  </div>

<script>
// Simple seedable RNG (Mulberry32)
function mulberry32(a) {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}

function generatePattern({
  wallWidth, w1, w2, gapMin, gapMax, ratio1, maxRun, seed
}) {
  const rng = mulberry32(seed >>> 0);
  const widths = [w1, w2];

  if (gapMax < gapMin) throw new Error("Max springa kan inte vara mindre än min springa.");
  if (Math.min(w1, w2) <= 0 || wallWidth <= 0) throw new Error("Ange positiva mått.");
  if (maxRun < 1) maxRun = 1;

  // Choose next board width with soft push towards target proportion and run-length limit
  const picks = [];
  let count1 = 0, count2 = 0;

  const minStep = (wi, gaps) => wi + (gaps > 0 ? gapMin : 0);

  let usedWidth = 0;
  let gaps = 0;

  while (true) {
    const remaining = wallWidth - usedWidth;
    // Try both options and see if at least one fits with min gap (except before first board)
    const fits1 = remaining >= minStep(w1, gaps);
    const fits2 = remaining >= minStep(w2, gaps);
    if (!fits1 && !fits2) break;

    // Enforce maxRun: if last maxRun are same, force the other if it fits
    const last = picks.slice(- (maxRun));
    let forced = null;
    if (last.length === maxRun && last.every(x => x === last[0])) {
      forced = last[0] === 1 ? 2 : 1;
    }

    let choice = null;
    if (forced) {
      if (forced === 1 && fits1) choice = 1;
      else if (forced === 2 && fits2) choice = 2;
      else {
        // Forced option doesn't fit; try the other if it fits
        if (forced === 1 && fits2) choice = 2;
        else if (forced === 2 && fits1) choice = 1;
      }
    } else {
      // Soft target: compute current share of type1 and bias pick prob
      const total = count1 + count2;
      const target = ratio1 / 100;
      let p1 = target;
      if (total > 0) {
        const diff = target - (count1 / total);
        p1 = Math.min(0.9, Math.max(0.1, target + diff * 0.8)); // dampening
      }
      const r = rng();
      const preferred = (r < p1) ? 1 : 2;

      // Try preferred if fits, else the other
      if (preferred === 1 && fits1) choice = 1;
      else if (preferred === 2 && fits2) choice = 2;
      else if (preferred === 1 && fits2) choice = 2;
      else if (preferred === 2 && fits1) choice = 1;
    }

    if (!choice) break; // nothing fits

    picks.push(choice);
    if (choice === 1) count1++; else count2++;

    usedWidth += (choice === 1 ? w1 : w2);
    if (picks.length > 1) { usedWidth += gapMin; gaps++; }
  }

  if (picks.length === 0) throw new Error("Inga brädor får plats med givna mått. Minska brädbredd eller springa.");

  // Now distribute extra space into gaps up to gapMax
  const n = picks.length;
  const baseContent = picks.reduce((sum, p, i) => sum + (p === 1 ? w1 : w2), 0);
  const baseGaps = (n - 1) * gapMin;
  let slack = wallWidth - (baseContent + baseGaps);
  if (slack < -1e-6) {
    throw new Error("Överfullt med minsta springa. Minska brädbredd/min springa eller öka väggbredd.");
  }

  const gapsArr = Array(Math.max(0, n - 1)).fill(gapMin);
  // Cap room per gap
  const caps = gapsArr.map(() => gapMax - gapMin);

  // Randomly distribute slack across gaps until either slack exhausted or caps filled
  let guard = 0;
  while (slack > 1e-6 && guard < 100000) {
    guard++;
    // Compute total remaining capacity
    let totalCap = caps.reduce((a,b) => a + Math.max(0, b), 0);
    if (totalCap <= 1e-6) break;

    // Pick a random gap weighted by remaining capacity
    let r = rng() * totalCap;
    let idx = 0;
    for (; idx < caps.length; idx++) {
      const c = Math.max(0, caps[idx]);
      if (r <= c) break;
      r -= c;
    }
    if (idx >= caps.length) idx = caps.length - 1;

    // Add a small increment (up to 5 mm or remaining capacity)
    const inc = Math.min(5, caps[idx], slack);
    gapsArr[idx] += inc;
    caps[idx] -= inc;
    slack -= inc;
  }

  // If slack remains but no capacity, we will add it as left/right marginal gaps equally (not counted in max gap)
  let leftMargin = 0, rightMargin = 0;
  if (slack > 1e-6) {
    leftMargin = Math.floor(slack / 2);
    rightMargin = Math.ceil(slack - leftMargin);
    slack = 0;
  }

  // Build positions from left
  let pos = leftMargin;
  const rows = [];
  for (let i = 0; i < n; i++) {
    const w = (picks[i] === 1 ? w1 : w2);
    const start = pos;
    const end = start + w;
    const gapAfter = (i < gapsArr.length) ? gapsArr[i] : rightMargin;
    rows.push({
      nr: i + 1,
      typ: picks[i] === 1 ? `Bredd 1 (${w1})` : `Bredd 2 (${w2})`,
      start_mm: Math.round(start),
      bredd_mm: w,
      slut_mm: Math.round(end),
      springa_efter_mm: Math.round(gapAfter)
    });
    pos = end + gapAfter;
  }

  const usedTotal = rows.length ? rows[rows.length - 1].slut_mm + rows[rows.length - 1].springa_efter_mm : 0;
  const maxGapUsed = rows.length > 1 ? Math.max(...gapsArr, leftMargin, rightMargin) : 0;

  return {
    rows,
    counts: { w1: count1, w2: count2 },
    maxGapUsed,
    leftMargin,
    rightMargin,
    totalUsed: usedTotal
  };
}

function fmt(n){ return new Intl.NumberFormat('sv-SE').format(n); }

function renderSummary(out, inputs) {
  const s = document.getElementById('summary');
  const free = inputs.wallWidth - out.totalUsed;
  s.innerHTML = `
    <div class="flex">
      <span class="pill">Brädor: ${out.rows.length}</span>
      <span class="pill">Bredd 1: ${out.counts.w1}</span>
      <span class="pill">Bredd 2: ${out.counts.w2}</span>
      <span class="pill">Max springa utnyttjad: ${fmt(out.maxGapUsed)} mm</span>
      <span class="pill">Vänster marginal: ${fmt(out.leftMargin)} mm</span>
      <span class="pill">Höger marginal: ${fmt(out.rightMargin)} mm</span>
      <span class="pill">Täckt bredd: ${fmt(out.totalUsed)} mm av ${fmt(inputs.wallWidth)} mm</span>
    </div>
  `;
}

function renderTable(rows) {
  const wrap = document.getElementById('tableWrap');
  const headers = ["#", "Typ", "Start (mm)", "Brädd (mm)", "Slut (mm)", "Springa efter (mm)"];
  const keys = ["nr", "typ", "start_mm", "bredd_mm", "slut_mm", "springa_efter_mm"];
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  headers.forEach(h => {
    const th = document.createElement('th');
    th.textContent = h;
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    keys.forEach(k => {
      const td = document.createElement('td');
      td.textContent = fmt(r[k]);
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  wrap.innerHTML = "";
  wrap.appendChild(table);
}

function getInputs() {
  const wallWidth = parseFloat(document.getElementById('wallWidth').value);
  const w1 = parseFloat(document.getElementById('w1').value);
  const w2 = parseFloat(document.getElementById('w2').value);
  const gapMax = parseFloat(document.getElementById('gapMax').value);
  const gapMin = parseFloat(document.getElementById('gapMin').value);
  const ratio1 = parseFloat(document.getElementById('ratio1').value);
  const maxRun = parseInt(document.getElementById('maxRun').value);
  const seed = parseInt(document.getElementById('seed').value);
  return { wallWidth, w1, w2, gapMin, gapMax, ratio1, maxRun, seed };
}

function toCSV(rows) {
  const header = ["nr","typ","start_mm","bredd_mm","slut_mm","springa_efter_mm"];
  const lines = [header.join(",")];
  rows.forEach(r => {
    lines.push([r.nr, r.typ, r.start_mm, r.bredd_mm, r.slut_mm, r.springa_efter_mm].join(","));
  });
  return lines.join("\n");
}

document.getElementById('btnRun').addEventListener('click', () => {
  const status = document.getElementById('status');
  status.textContent = "";
  try {
    const inputs = getInputs();
    const out = generatePattern(inputs);
    renderSummary(out, inputs);
    renderTable(out.rows);
    status.innerHTML = '<span class="ok">Klart ✔</span>';
  } catch (e) {
    status.innerHTML = '<span class="error">' + e.message + '</span>';
  }
});

document.getElementById('btnCSV').addEventListener('click', () => {
  const tbl = document.querySelector('#tableWrap table');
  if (!tbl) { alert('Generera mönster först.'); return; }
  // Reconstruct rows from DOM
  const rows = [];
  const trs = tbl.querySelectorAll('tbody tr');
  trs.forEach(tr => {
    const tds = tr.querySelectorAll('td');
    rows.push({
      nr: tds[0].textContent,
      typ: tds[1].textContent,
      start_mm: tds[2].textContent,
      bredd_mm: tds[3].textContent,
      slut_mm: tds[4].textContent,
      springa_efter_mm: tds[5].textContent
    });
  });
  const csv = toCSV(rows);
  const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'fasad-indelning.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>
